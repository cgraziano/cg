/****************************************************************************
Copyright (c) 2014, Colorado School of Mines and others. All rights reserved.
This program and accompanying materials are made available under the terms of
the Common Public License - v1.0, which accompanies this distribution, and is
available at http://www.eclipse.org/legal/cpl-v10.html
****************************************************************************/
package wwarp;

import edu.mines.jtk.dsp.*;
import edu.mines.jtk.lapack.*;
import edu.mines.jtk.mosaic.*;
import edu.mines.jtk.util.Check;
import static edu.mines.jtk.dsp.Conv.*;
import static edu.mines.jtk.util.ArrayMath.*;

/**
 * Estimates a wavelet from alignment by warping of sequences or images.
 * The two sequences or images are assumed to have been convolved with the
 * same wavelet. Warping of one sequence or image to align with the other will
 * cause the wavelet to be stretched or squeezed, and this distortion enables
 * us to estimate the wavelet.
 * <p>
 * For images, convolution with the wavelet is assumed to be in only the 1st
 * dimension. For definiteness, this 1st dimension is assumed to be time in
 * the documentation below.
 *
 * @author Dave Hale, Colorado School of Mines
 * @version 2014.01.27
 */
public class WaveletWarping {

  /**
   * Sets the min-max range of times used to estimate wavelet.
   * @param itmin minimum time, in samples.
   * @param itmax maximum time, in samples.
   */
  public void setTimeRange(int itmin, int itmax) {
    _itmin = itmin;
    _itmax = itmax;
  }

  /**
   * Sets the min-max range of positions used to estimate wavelet.
   * @param itmin minimum position, in samples.
   * @param itmax maximum position, in samples.
   */
  public void setSpaceRange(int ixmin, int ixmax) {
    _ixmin = ixmin;
    _ixmax = ixmax;
  }

  /**
   * Sets the min-max range of frequencies used to estimate the wavelet.
   * If the specified min-max bounds on frequency are not a subset of the
   * zero-Nyquist range [0,0.5], then no bandpass filter is used. The default
   * is to use no bandpass filter.
   * @param fmin minimum frequency, in cycles/sample.
   * @param fmax maximum frequency, in cycles/sample.
   */
  public void setFrequencyRange(double fmin, double fmax) {
    if (fmin<fmax && (0.0<fmin || fmax<0.5)) {
      _bpf = new BandPassFilter(fmin,fmax,0.05,0.01);
    } else {
      _bpf = null;
    }
  }

  /**
   * Sets the stability factor by which to scale zero-lag of correlations.
   * A factor slightly greater than one may stabilize estimates of
   * inverse wavelets A.
   * @param sfac stability factor.
   */
  public void setStabilityFactor(double sfac) {
    _sfac = sfac;
  }

  /**
   * Returns inverse wavelet a estimated by warping one sequence to another.
   * The sequences are related by warping such that f[t] ~ g[u[t]].
   * @param na number of samples in the inverse wavelet a.
   * @param ka the sample index for a[0].
   * @param u array of samples for warping u[t].
   * @param f array of samples for sequence f[t].
   * @param g array of samples for sequence g[t]
   * @return array of coefficients for the inverse wavelet a.
   */
  public float[] getInverseA(
    int na, int ka, float[] u, float[] f, float[] g)
  {
    int nt = u.length;
    Check.argument(-na<ka,"-na<ka");
    Check.argument(ka<=0,"ka<=0");

    // Differences d for all lags of inverse wavelet a.
    float[][] d = computeDifferences(na,ka,u,f,g);
    

    // The matrix C and right-hand-side vector b, for Ca = b. For zero lag, we
    // have a0 = a[-ka] = 1, so that only na-1 coefficients of a are unknown;
    // the unknown coefficients are those corresponding to non-zero lags.
    int ma = na-1;
    DMatrix c = new DMatrix(ma,ma);
    DMatrix b = new DMatrix(ma,1);
    for (int ia=0,ic=0; ia<na; ++ia) {
      if (ia==-ka) continue; // skip lag zero, because a0 = 1
      for (int ja=0,jc=0; ja<na; ++ja) {
        if (ja==-ka) continue; // skip lag zero, because a0 = 1
        double cij = dot(d[ia],d[ja]);
        c.set(ic,jc,cij);
        ++jc;
      }
      c.set(ic,ic,c.get(ic,ic)*_sfac);
      double bi = -dot(d[ia],d[-ka]);
      b.set(ic,0,bi);
      ++ic;
    }
    //System.out.println("c=\n"+c);
    //System.out.println("b=\n"+b);

    // Solve for inverse filter a using Cholesky decomposition of C.
    DMatrixChd chd = new DMatrixChd(c);
    DMatrix a = chd.solve(b);
    
    float[] aa = new float[na];
    for (int ia=0,ic=0; ia<na; ++ia) {
      if (ia==-ka) {
        aa[ia] = 1.0f; // lag 0, so a0 = 1
      } else {
        aa[ia] = (float)a.get(ic,0);
        ++ic;
      }
    }
    return aa;
  }

  /**
   * Returns inverse wavelet a estimated by warping one sequence to another.
   * The sequences are related by warping such that f[x][t] ~ g[x][u[t]].
   * @param na number of samples in the inverse wavelet a.
   * @param ka the sample index for a[0].
   * @param u array of samples for warping u[x][t].
   * @param f array of samples for sequence f[x][t].
   * @param g array of samples for sequence g[x][t]
   * @return array of coefficients for the inverse wavelet a.
   */
  public float[] getInverseA(
    int na, int ka, float[][] u, float[][] f, float[][] g)
  {

    int nt = u.length;
    Check.argument(-na<ka,"-na<ka");
    Check.argument(ka<=0,"ka<=0");

    // Differences d for all lags of inverse wavelet a.
    float[][][] d = computeDifferences(na,ka,u,f,g);

    // The matrix C and right-hand-side vector b, for Ca = b. For zero lag, we
    // have a0 = a[-ka] = 1, so that only na-1 coefficients of a are unknown;
    // the unknown coefficients are those corresponding to non-zero lags.
    int ma = na-1;
    DMatrix c = new DMatrix(ma,ma);
    DMatrix b = new DMatrix(ma,1);
    for (int ia=0,ic=0; ia<na; ++ia) {
      if (ia==-ka) continue; // skip lag zero, because a0 = 1
      for (int ja=0,jc=0; ja<na; ++ja) {
        if (ja==-ka) continue; // skip lag zero, because a0 = 1
        double cij = dot(d[ia],d[ja]);
        c.set(ic,jc,cij);
        ++jc;
      }
      c.set(ic,ic,c.get(ic,ic)*_sfac);
      double bi = -dot(d[ia],d[-ka]);
      b.set(ic,0,bi);
      ++ic;
    }
    //System.out.println("c=\n"+c);
    //System.out.println("b=\n"+b);

    // Solve for inverse filter a using Cholesky decomposition of C.
    DMatrixChd chd = new DMatrixChd(c);
    DMatrix a = chd.solve(b);
    float[] aa = new float[na];
    for (int ia=0,ic=0; ia<na; ++ia) {
      if (ia==-ka) {
        aa[ia] = 1.0f; // lag 0, so a0 = 1
      } else {
        aa[ia] = (float)a.get(ic,0);
        ++ic;
      }
    }
    return aa;
  }


  /**
   * Returns inverse wavelet a estimated by warping one sequence
   * to another. Iterative process minimizing the differences between
   * HFa and HSLGa.
   * The sequences are related by warping such that f[t] ~ g[u[t]].
   * @param na number of samples in the inverse wavelet a.
   * @param ka the sample index for a[0].
   * @param u array of samples for warping u[t].
   * @param f array of samples for sequence f[t].
   * @param g array of samples for sequence g[t]
   * @return array of coefficients for the inverse wavelet a.
   */
  public float[] getInverseAIter(
    int na, int ka, int nh, int kh, int niter, 
    float[] u, float[] f, float[] g)
  {
    int nt = u.length;
    Check.argument(-na<ka,"-na<ka");
    Check.argument(ka<=0,"ka<=0");

    float[] h = new float[nh];
    float[] aa = new float[na];
    h[-kh] = 1.0f;

    for (int iter=0; iter<niter; ++iter) {
      h = applyB(h);

      // Differences d for all lags of inverse wavelet a.
      float[][] d = computeDifferencesIter(na,ka,nh,kh,h,u,f,g);

      // The matrix C and right-hand-side vector b, for Ca = b. For zero lag, we
      // have a0 = a[-ka] = 1, so that only na-1 coefficients of a are unknown;
      // the unknown coefficients are those corresponding to non-zero lags.
      int ma = na-1;
      DMatrix c = new DMatrix(ma,ma);
      DMatrix b = new DMatrix(ma,1);
      for (int ia=0,ic=0; ia<na; ++ia) {
        if (ia==-ka) continue; // skip lag zero, because a0 = 1
        for (int ja=0,jc=0; ja<na; ++ja) {
          if (ja==-ka) continue; // skip lag zero, because a0 = 1
          double cij = dot(d[ia],d[ja]);
          c.set(ic,jc,cij);
          ++jc;
        }
        c.set(ic,ic,c.get(ic,ic)*_sfac);
        double bi = -dot(d[ia],d[-ka]);
        b.set(ic,0,bi);
        ++ic;
      }
      //System.out.println("c=\n"+c);
      //System.out.println("b=\n"+b);

      // Solve for inverse filter a using Cholesky decomposition of C.
      DMatrixChd chd = new DMatrixChd(c);
      DMatrix a = chd.solve(b);
      aa = new float[na];
      for (int ia=0,ic=0; ia<na; ++ia) {
        if (ia==-ka) {
          aa[ia] = 1.0f; // lag 0, so a0 = 1
        } else {
          aa[ia] = (float)a.get(ic,0);
          ++ic;
        }
      }
      System.out.println("Inverse Coefficients, Iteration: "+iter);
      dump(aa);
      h = getWaveletH(na,ka,aa,nh,kh);
    }
    return aa;
  }

  /**
   * Returns inverse wavelet a estimated by warping one sequence to another.
   * The sequences are related by warping such that f[x][t] ~ g[x][u[t]].
   * @param na number of samples in the inverse wavelet a.
   * @param ka the sample index for a[0].
   * @param u array of samples for warping u[x][t].
   * @param f array of samples for sequence f[x][t].
   * @param g array of samples for sequence g[x][t]
   * @return array of coefficients for the inverse wavelet a.
   */
  public float[] getInverseAIter(
    int na, int ka, int nh, int kh, int niter,
    float[][] u, float[][] f, float[][] g)
  {

    int nt = u.length;
    Check.argument(-na<ka,"-na<ka");
    Check.argument(ka<=0,"ka<=0");

    float[] h = new float[nh];
    float[] aa = new float[na];
    h[0] = 1.0f;

    for (int iter=0; iter<niter; ++iter) {

      // Differences d for all lags of inverse wavelet a.
      float[][][] d = computeDifferencesIter(na,ka,nh,kh,h,u,f,g);

      // The matrix C and right-hand-side vector b, for Ca = b. For zero lag, we
      // have a0 = a[-ka] = 1, so that only na-1 coefficients of a are unknown;
      // the unknown coefficients are those corresponding to non-zero lags.
      int ma = na-1;
      DMatrix c = new DMatrix(ma,ma);
      DMatrix b = new DMatrix(ma,1);
      for (int ia=0,ic=0; ia<na; ++ia) {
        if (ia==-ka) continue; // skip lag zero, because a0 = 1
        for (int ja=0,jc=0; ja<na; ++ja) {
          if (ja==-ka) continue; // skip lag zero, because a0 = 1
          double cij = dot(d[ia],d[ja]);
          c.set(ic,jc,cij);
          ++jc;
        }
        c.set(ic,ic,c.get(ic,ic)*_sfac);
        double bi = -dot(d[ia],d[-ka]);
        b.set(ic,0,bi);
        ++ic;
      }
      //System.out.println("c=\n"+c);
      //System.out.println("b=\n"+b);

      // Solve for inverse filter a using Cholesky decomposition of C.
      DMatrixChd chd = new DMatrixChd(c);
      DMatrix a = chd.solve(b);
      aa = new float[na];
      for (int ia=0,ic=0; ia<na; ++ia) {
        if (ia==-ka) {
          aa[ia] = 1.0f; // lag 0, so a0 = 1
        } else {
          aa[ia] = (float)a.get(ic,0);
          ++ic;
        }
      }
      h = getWaveletH(na,ka,aa,nh,kh);
      System.out.println("Inverse Coefficients, Iteration: "+iter);
      dump(aa);
    }
    return aa;
  }


  /**
   * Returns inverse wavelet by solving the normal equation
   * ' = Transpose
   * (HSLG)'(HSLG)a=(HSLG)'f
   * Note that this process does not assume HA=I, it only assumes
   * that H=I fro the first iteration.
   * The sequences are related by warping such that f[x][t] ~ g[x][u[t]].
   * @param na number of samples in the inverse wavelet a.
   * @param ka the sample index for a[0].
   * @param u array of samples for warping u[x][t].
   * @param f array of samples for sequence f[x][t].
   * @param g array of samples for sequence g[x][t]
   * @return array of coefficients for the inverse wavelet a.
   */
  public float[] getInverseAIter2(
    int na, int ka, int nh, int kh, int niter,
    float[] u, float[] f, float[] g)
  {

    int nt = u.length;
    Check.argument(-na<ka,"-na<ka");
    Check.argument(ka<=0,"ka<=0");

    float[] h = new float[nh];
    float[] aa = new float[na];
    h[-kh] = 1.0f;

    for (int iter=0; iter<niter; ++iter) {

      // Differences d for all lags of inverse wavelet a.
      float[][] z = computeZ(na,ka,nh,kh,h,u,f,g);

      // The matrix C and right-hand-side vector b, for Ca = b. For zero lag, we
      // have a0 = a[-ka] = 1, so that only na-1 coefficients of a are unknown;
      // the unknown coefficients are those corresponding to non-zero lags.
      //int ma = na-1;
      DMatrix c = new DMatrix(na,na);
      DMatrix b = new DMatrix(na,1);
      for (int ia=0; ia<na; ++ia) {
        for (int ja=0; ja<na; ++ja) {
          double cij = dot(z[ia],z[ja]);
          c.set(ia,ja,cij);
        }
        c.set(ia,ia,c.get(ia,ia)*_sfac);
        double bi = dot(z[ia],f);
        b.set(ia,0,bi);
      }
      System.out.println("c=\n"+c);
      System.out.println("b=\n"+b);

      // Solve for inverse filter a using Cholesky decomposition of C.
      DMatrixChd chd = new DMatrixChd(c);
      DMatrix a = chd.solve(b);
      aa = new float[na];
      for (int ia=0; ia<na; ++ia) {
        aa[ia] = (float)a.get(ia,0);
        //aa[ia] = (float)a.get(ic,0);
        //++ic;
      }
      

      float[] ga = applyA(na,ka,aa,g);
      float[] lga = applyL(u,ga);
      float[] slga = applyS(u,lga);
      SimplePlot.asPoints(slga);
      SimplePlot.asPoints(f);
      h = ShapingFilter.design(nh,kh,nt,0,slga,nt,0,f);
      //h = getWaveletH(na,ka,aa,nh,kh);
      System.out.println("Inverse Coefficients, Iteration: "+iter);
      dump(aa);
    }
    return aa;
  }

  /**
   * Returns inverse wavelet by solving the normal equation
   * ' = Transpose
   * (HSLG)'(HSLG)a=(HSLG)'f
   * The sequences are related by warping such that f[x][t] ~ g[x][u[t]].
   * @param na number of samples in the inverse wavelet a.
   * @param ka the sample index for a[0].
   * @param u array of samples for warping u[x][t].
   * @param f array of samples for sequence f[x][t].
   * @param g array of samples for sequence g[x][t]
   * @return array of coefficients for the inverse wavelet a.
   */
  public float[] getInverseAIter2(
      int na, int ka, int nh, int kh, int niter,
      float[][] u, float[][] f, float[][] g)
  {

    int nt = u[0].length;
    Check.argument(-na<ka,"-na<ka");
    Check.argument(ka<=0,"ka<=0");

    float[] h = new float[nh];
    float[] aa = new float[na];
    h[-kh] = 1.0f;

    for (int iter=0; iter<niter; ++iter) {

      // Differences d for all lags of inverse wavelet a.
      float[][][] z = computeZ(na,ka,nh,kh,h,u,f,g);

      // The matrix C and right-hand-side vector b, for Ca = b. For zero lag, we
      // have a0 = a[-ka] = 1, so that only na-1 coefficients of a are unknown;
      // the unknown coefficients are those corresponding to non-zero lags.
      //int ma = na-1;
      DMatrix c = new DMatrix(na,na);
      DMatrix b = new DMatrix(na,1);
      for (int ia=0,ic=0; ia<na; ++ia) {
        for (int ja=0,jc=0; ja<na; ++ja) {
          double cij = dot(z[ia],z[ja]);
          c.set(ia,ja,cij);
        }
        c.set(ia,ia,c.get(ia,ia)*_sfac);
        double bi = dot(z[ia],f);
        b.set(ia,0,bi);
      }
      //System.out.println("c=\n"+c);
      //System.out.println("b=\n"+b);

      // Solve for inverse filter a using Cholesky decomposition of C.
      DMatrixChd chd = new DMatrixChd(c);
      DMatrix a = chd.solve(b);
      aa = new float[na];
      for (int ia=0,ic=0; ia<na; ++ia) {
        aa[ia] = (float)a.get(ia,0);
      }
      float[][] ga = applyA(na,ka,aa,g);
      float[][] lga = applyL(u,ga);
      float[][] slga = applyS(u,lga);
      h = ShapingFilter.design(nh,kh,nt,0,slga,nt,0,f);
      SimplePlot.asPoints(h);
      System.out.println("Inverse Coefficients, Iteration: "+iter);
      dump(aa);
    }
    return aa;
  }

  /**
   * Estimates the inverse wavelet and the wavelet coefficients
   * using iteratively reweighted least squares.
   * @param na
   * @param ka
   * @param a
   * @param nh
   * @param kh
   * @param h
   * @param niter
   * @param eps
   */
  public float[][] getAHIter3(
    int na, int ka,
    int nh, int kh, float[] h,
    int niter, float eps,
    float[] u, float[] f, float[] g) 
  {
    float[] a = new float[na];
    for (int iter=0; iter<niter; ++iter) {
      a = getInverseAIter3(na,ka,nh,kh,h,eps,u,f,g);
      //a[0] = 0.667235f;
      //a[1] = -0.81479f;
      //a[2] = 0.369160f;
      h = getWaveletHIter3(na,ka,a,nh,kh,eps,u,f,g);
    }
    float[][] ah = {a,h};
    return ah;
  }

  /**
   * Estimates the inverse wavelet and the wavelet coefficients
   * using iteratively reweighted least squares.
   * @param na
   * @param ka
   * @param a
   * @param nh
   * @param kh
   * @param h
   * @param niter
   * @param eps
   */
  public float[][] getAHIter3(
    int na, int ka,
    int nh, int kh, float[] h,
    int niter, float eps,
    float[][] u, float[][] f, float[][] g) 
  {
    float[] a = new float[na];
    float[] he = h;
    for (int iter=0; iter<niter; ++iter) {
      a = getInverseAIter3(na,ka,nh,kh,he,eps,u,f,g);
      //a[0] = 0.667235f;
      //a[1] = -0.81479f;
      //a[2] = 0.369160f;
      he = getWaveletHIter3(na,ka,a,nh,kh,eps,u,f,g);
    }
    float[][] ah = {a,he};
    return ah;
  }

  /**
   * Returns inverse wavelet by solving the linear system of equations
   * (P'P+(eps^2)*H'H)a = P'f+(eps^2)H'*delta.
   * eps indicates the amount of weight assigned to the constraint
   * HA=I
   * ' is transpose
   * delta is essentially I.
   * The sequences are related by warping such that f[t] ~ g[u[t]].
   * @param na number of samples in the inverse wavelet a.
   * @param ka the sample index for a[0].
   * @param u array of samples for warping u[t].
   * @param f array of samples for sequence f[t].
   * @param g array of samples for sequence g[t]
   * @return array of coefficients for the inverse wavelet a.
   */
  public float[] getInverseAIter3(
    int na, int ka, 
    int nh, int kh, float[] h, 
    float eps, float[] u, float[] f, float[] g)
  {

    int nt = u.length;
    Check.argument(-na<ka,"-na<ka");
    Check.argument(ka<=0,"ka<=0");

    float[] delta = new float[nh];
    float[] aa = new float[na];
    delta[-kh] = 1.0f;

    //vectors necessary to build C matrix in Ca=b for the necessary
    //inverse wavelet coefficients
    float[] autocorh = new float[na];
    float[] xcorhdelta = new float[na];
    float[][] p = computeP(na,ka,nh,kh,h,u,f,g);
    xcor(nh,kh,h,nh,kh,h,na,0,autocorh);
    xcor(nh,kh,h,nh,kh,delta,na,ka,xcorhdelta);

    // The matrix C and right-hand-side vector b, for Ca = b. For zero lag, we
    // have a0 = a[-ka] = 1, so that only na-1 coefficients of a are unknown;
    // the unknown coefficients are those corresponding to non-zero lags.
    //int ma = na-1;
    DMatrix c = new DMatrix(na,na);
    DMatrix b = new DMatrix(na,1);
    for (int ia=0; ia<na; ++ia) {
      for (int ja=0; ja<na; ++ja) {
        double cij = dot(p[ia],p[ja])+eps*eps*autocorh[abs(ia-ja)];
        c.set(ia,ja,cij);
      }
      c.set(ia,ia,c.get(ia,ia)*_sfac);
      double bi = dot(p[ia],f)+eps*eps*xcorhdelta[ia];
      b.set(ia,0,bi);
    }
    System.out.println("c=\n"+c);
    System.out.println("b=\n"+b);

    // Solve for inverse filter a using Cholesky decomposition of C.
    DMatrixChd chd = new DMatrixChd(c);
    DMatrix a = chd.solve(b);
    aa = new float[na];
    for (int ia=0; ia<na; ++ia) {
      aa[ia] = (float)a.get(ia,0);
      //aa[ia] = (float)a.get(ic,0);
      //++ic;
    }
    
    return aa;
  }

  
  /**
   * Returns inverse wavelet by solving the linear system of equations
   * (P'P+(eps^2)*H'H)a = P'f+(eps^2)H'*delta.
   * eps indicates the amount of weight assigned to the constraint
   * HA=I
   * ' is transpose
   * delta is essentially I.
   * The sequences are related by warping such that f[x][t] ~ g[x][u[t]].
   * @param na number of samples in the inverse wavelet a.
   * @param ka the sample index for a[0].
   * @param u array of samples for warping u[x][t].
   * @param f array of samples for sequence f[x][t].
   * @param g array of samples for sequence g[x][t]
   * @return array of coefficients for the inverse wavelet a.
   */
  public float[] getInverseAIter3(
    int na, int ka, 
    int nh, int kh, float[] h, 
    float eps, float[][] u, float[][] f, float[][] g)
  {

    int nt = u[0].length;
    Check.argument(-na<ka,"-na<ka");
    Check.argument(ka<=0,"ka<=0");

    float[] delta = new float[nh];
    float[] aa = new float[na];
    delta[-kh] = 1.0f;

    //vectors necessary to build C matrix in Ca=b for the necessary
    //inverse wavelet coefficients
    float[] autocorh = new float[na];
    float[] xcorhdelta = new float[na];
    float[][][] p = computeP(na,ka,nh,kh,h,u,f,g);
    xcor(nh,kh,h,nh,kh,h,na,0,autocorh);
    xcor(nh,kh,h,nh,kh,delta,na,ka,xcorhdelta);

    // The matrix C and right-hand-side vector b, for Ca = b. For zero lag, we
    // have a0 = a[-ka] = 1, so that only na-1 coefficients of a are unknown;
    // the unknown coefficients are those corresponding to non-zero lags.
    //int ma = na-1;
    DMatrix c = new DMatrix(na,na);
    DMatrix b = new DMatrix(na,1);
    for (int ia=0; ia<na; ++ia) {
      for (int ja=0; ja<na; ++ja) {
        double cij = dot(p[ia],p[ja])+eps*eps*autocorh[abs(ia-ja)];
        c.set(ia,ja,cij);
      }
      c.set(ia,ia,c.get(ia,ia)*_sfac);
      double bi = dot(p[ia],f)+eps*eps*xcorhdelta[ia];
      b.set(ia,0,bi);
    }
    System.out.println("ca=\n"+c);
    System.out.println("ba=\n"+b);

    // Solve for inverse filter a using Cholesky decomposition of C.
    DMatrixChd chd = new DMatrixChd(c);
    DMatrix a = chd.solve(b);
    aa = new float[na];
    for (int ia=0; ia<na; ++ia) {
      aa[ia] = (float)a.get(ia,0);
      //aa[ia] = (float)a.get(ic,0);
      //++ic;
    }
    
    return aa;
  }

  /**
   * Returns wavelet by solving the linear system of equations
   * with the newly estimated inverse wavelet.
   * (Q'Q+(eps^2)*A'A)h = Q'f+(eps^2)A'*delta.
   * eps indicates the amount of weight assigned to the constraint
   * HA=I
   * ' is transpose
   * delta is essentially I.
   * The sequences are related by warping such that f[t] ~ g[u[t]].
   * @param na number of samples in the inverse wavelet a.
   * @param ka the sample index for a[0].
   * @param u array of samples for warping u[t].
   * @param f array of samples for sequence f[t].
   * @param g array of samples for sequence g[t]
   * @return array of coefficients for the inverse wavelet a.
   */
  public float[] getWaveletHIter3(
    int na, int ka, float[] a, int nh, int kh, float eps,
    float[] u, float[] f, float[] g)
  {

    int nt = u.length;
    Check.argument(-na<ka,"-na<ka");
    Check.argument(ka<=0,"ka<=0");

    float[] delta = new float[na];
    float[] hh = new float[nh];
    delta[-ka] = 1.0f;


    //vectors necessary to build C matrix in Ch=b for the necessary
    //inverse wavelet coefficients
    float[] ag = applyA(na,ka,a,g);
    float[] lag = applyL(u,ag);
    float[] q = applyS(u,lag);//q in the math, is really slag
    float[] acorq = new float[nh];
    float[] acora = new float[nh];
    float[] xcoradelta = new float[nh];
    float[] xcorqf = new float[nh];
    xcor(na,ka,a,na,ka,a,nh,0,acora);
    xcor(na,ka,a,na,ka,delta,nh,kh,xcoradelta);

    int itlo = (_itmin<_itmax)?_itmin:0;
    int ithi = (_itmin<_itmax)?_itmax:nt-1;

    int ntlim = ithi-itlo+1;
    float[] qlim = new float[ntlim];
    float[] flim = new float[ntlim];
    int jx = 0;
    int jt = 0;
    for (int it=itlo; it<=ithi; ++it) {
      qlim[jt] = q[it];
      flim[jt] = f[it];
      ++jt;
    }
    xcor(nt,0,qlim,nt,0,qlim,nh,0,acorq);
    xcor(nt,0,qlim,nt,0,flim,nh,kh,xcorqf);

    // The matrix C and right-hand-side vector b, for Ca = b. For zero lag, we
    // have a0 = a[-ka] = 1, so that only na-1 coefficients of a are unknown;
    // the unknown coefficients are those corresponding to non-zero lags.
    //int ma = na-1;
    DMatrix c = new DMatrix(nh,nh);
    DMatrix b = new DMatrix(nh,1);
    for (int ih=0; ih<nh; ++ih) {
      for (int jh=0; jh<nh; ++jh) {
        double cij = acorq[abs(ih-jh)]+eps*eps*acora[abs(ih-jh)];
        c.set(ih,jh,cij);
      }
      c.set(ih,ih,c.get(ih,ih));
      double bi = xcorqf[ih]+eps*eps*xcoradelta[ih];

      b.set(ih,0,bi);
    }
    System.out.println("ch=\n"+c);
    System.out.println("bh=\n"+b);

    // Solve for inverse filter a using Cholesky decomposition of C.
    DMatrixChd chd = new DMatrixChd(c);
    DMatrix h = chd.solve(b);
    for (int ih=0; ih<nh; ++ih) {
      hh[ih] = (float)h.get(ih,0);
      //aa[ia] = (float)a.get(ic,0);
      //++ic;
    }
    
    return hh;
  }


  /**
   * Returns wavelet by solving the linear system of equations
   * with the newly estimated inverse wavelet.
   * (Q'Q+(eps^2)*A'A)h = Q'f+(eps^2)A'*delta.
   * eps indicates the amount of weight assigned to the constraint
   * HA=I
   * ' is transpose
   * delta is essentially I.
   * The sequences are related by warping such that f[x][t] ~ g[x][u[t]].
   * @param na number of samples in the inverse wavelet a.
   * @param ka the sample index for a[0].
   * @param u array of samples for warping u[x][t].
   * @param f array of samples for sequence f[x][t].
   * @param g array of samples for sequence g[x][t]
   * @return array of coefficients for the inverse wavelet a.
   */
  public float[] getWaveletHIter3(
    int na, int ka, float[] a, int nh, int kh, float eps,
    float[][] u, float[][] f, float[][] g)
  {

    int nt = u[0].length;
    int nx = u.length;
    Check.argument(-na<ka,"-na<ka");
    Check.argument(ka<=0,"ka<=0");

    float[] delta = new float[na];
    float[] hh = new float[nh];
    delta[-ka] = 1.0f;


    //vectors necessary to build C matrix in Ch=b for the necessary
    //inverse wavelet coefficients
    float[][] ag = applyA(na,ka,a,g);
    float[][] lag = applyL(u,ag);
    float[][] q = applyS(u,lag);//q in the math, is really slag
    float[] acorq = new float[nh];
    float[] acorqtemp = new float[nh];
    float[] acora = new float[nh];
    float[] xcoradelta = new float[nh];
    float[] xcorqf = new float[nh];
    float[] xcorqftemp = new float[nh];

    int itlo = (_itmin<_itmax)?_itmin:0;
    int ithi = (_itmin<_itmax)?_itmax:nt-1;
    int ixlo = (_ixmin<_ixmax)?_ixmin:0;
    int ixhi = (_ixmin<_ixmax)?_ixmax:nx-1;

    xcor(na,ka,a,na,ka,a,nh,0,acora);
    xcor(na,ka,a,na,ka,delta,nh,kh,xcoradelta);
    int ntlim = ithi-itlo+1;
    int nxlim = ixhi-ixlo+1;
    float[][] qlim = new float[nxlim][ntlim];
    float[][] flim = new float[nxlim][ntlim];
    System.out.println("ntlimz = "+ntlim);
    System.out.println("nt = "+nt);
    int jx = 0;
    int jt = 0;
    for (int ix=ixlo; ix<ixhi; ++ix) {
      jt = 0;
      for (int it=itlo; it<=ithi; ++it) {
        qlim[jx][jt] = q[ix][it];
        flim[jx][jt] = f[ix][it];
        ++jt;
      }
      ++jx;
    }

    for (int ix=0; ix<nxlim; ++ix) {
      xcor(ntlim,0,qlim[ix],ntlim,0,flim[ix],nh,kh,xcorqftemp);
      xcor(ntlim,0,qlim[ix],ntlim,0,qlim[ix],nh,0,acorqtemp);
      xcorqf = add(xcorqf,xcorqftemp);
      acorq = add(acorq,acorqtemp);
    }


    // The matrix C and right-hand-side vector b, for Ca = b. For zero lag, we
    // have a0 = a[-ka] = 1, so that only na-1 coefficients of a are unknown;
    // the unknown coefficients are those corresponding to non-zero lags.
    //int ma = na-1;
    DMatrix c = new DMatrix(nh,nh);
    DMatrix b = new DMatrix(nh,1);
    for (int ih=0; ih<nh; ++ih) {
      for (int jh=0; jh<nh; ++jh) {
        double cij = acorq[abs(ih-jh)]+eps*eps*acora[abs(ih-jh)];
        c.set(ih,jh,cij);
      }
      c.set(ih,ih,c.get(ih,ih));
      double bi = xcorqf[ih]+eps*eps*xcoradelta[ih];

      b.set(ih,0,bi);
    }
    System.out.println("ch=\n"+c);
    System.out.println("bh=\n"+b);

    // Solve for inverse filter a using Cholesky decomposition of C.
    DMatrixChd chd = new DMatrixChd(c);
    DMatrix h = chd.solve(b);
    for (int ih=0; ih<nh; ++ih) {
      hh[ih] = (float)h.get(ih,0);
      //aa[ia] = (float)a.get(ic,0);
      //++ic;
    }
    
    return hh;
  }






  
  /**
   * Returns inverse wavelet a estimated via PEF of sequence.
   * @param na number of samples in the inverse wavelet a.
   * @param ka the sample index for a[0].
   * @param f array of samples for sequence f(t).
   * @return array of coefficients for the inverse wavelet a.
   */
  public float[] getInverseAPef(int na, int ka, float[] f) {
    int nt = f.length;

    // Sequence for different time shifts
    float[][] d = new float[na][nt];
    for (int ia=0; ia<na; ++ia) {
      d[ia] = delay(ka+ia,f);
    }

    // The matrix C and right-hand-side vector b, for Ca = b. For zero lag, we
    // have a0 = a[-ka] = 1, so that only na-1 coefficients of a are unknown;
    // the unknown coefficients are those corresponding to non-zero lags.
    int ma = na-1;
    DMatrix c = new DMatrix(ma,ma);
    DMatrix b = new DMatrix(ma,1);
    for (int ia=0,ic=0; ia<na; ++ia) {
      if (ia==-ka) continue; // skip lag zero, because a0 = 1
      for (int ja=0,jc=0; ja<na; ++ja) {
        if (ja==-ka) continue; // skip lag zero, because a0 = 1
        double cij = dot(d[ia],d[ja]);
        c.set(ic,jc,cij);
        ++jc;
      }
      c.set(ic,ic,c.get(ic,ic)*_sfac);
      double bi = -dot(d[ia],d[-ka]);
      b.set(ic,0,bi);
      ++ic;
    }
    //System.out.println("c=\n"+c);
    //System.out.println("b=\n"+b);

    // Solve for inverse filter a using Cholesky decomposition of C.
    DMatrixChd chd = new DMatrixChd(c);
    DMatrix a = chd.solve(b);
    float[] aa = new float[na];
    for (int ia=0,ic=0; ia<na; ++ia) {
      if (ia==-ka) {
        aa[ia] = 1.0f; // lag 0, so a0 = 1
      } else {
        aa[ia] = (float)a.get(ic,0);
        ++ic;
      }
    }
    return aa;
  }

  /**
   * Estimates the wavelet h from the inverse wavelet a.
   * @param na number of samples in the inverse wavelet a.
   * @param ka the sample index for a[0].
   * @param a array of coefficients for the inverse wavelet a.
   * @param nh number of samples in the wavelet h.
   * @param kh the sample index for h[0].
   */
  public float[] getWaveletH(int na, int ka, float[] a, int nh, int kh) {
    float[] one = {1.0f};
    float[] ca1 = new float[nh];
    float[] caa = new float[nh];
    xcor(na,ka,a,1,0,one,nh,kh,ca1);
    xcor(na,ka,a,na,ka,a,nh, 0,caa);
    caa[0] *= _sfac;
    SymmetricToeplitzFMatrix stm = new SymmetricToeplitzFMatrix(caa);
    return stm.solve(ca1);
  }

  /**
   * Applies the specified inverse wavelet A.
   * @param f array with input sequence f(t).
   * @return array with filtered output sequence.
   */
  public float[] applyA(int na, int ka, float[] a, float[] f) {
    return convolve(na,ka,a,f);
  }

  /**
   * Applies the specified inverse wavelet A.
   * @param f array with input sequence f(t).
   * @return array with filtered output sequence.
   */
  public float[][] applyA(int na, int ka, float[] a, float[][] f) {
    int nx = f.length;
    int nt = f[0].length;
    float[][] af = new float[nx][nt];
    for (int ix=0; ix<nx; ++ix)
      af[ix] = convolve(na,ka,a,f[ix]);
    return af;
  }

  /**
   * Applies the specified wavelet H.
   * @param f array with input sequence f(t).
   * @return array with filtered output sequence.
   */
  public float[] applyH(int nh, int kh, float[] h, float[] f) {
    return convolve(nh,kh,h,f);
  }

  /**
   * Applies the specified wavelet H.
   * @param f array with input sequence f(t).
   * @return array with filtered output sequence.
   */
  public float[][] applyH(int nh, int kh, float[] h, float[][] f) {
    int nx = f.length;
    int nt = f[0].length;
    float[][] hf = new float[nx][nt];
    for (int ix=0; ix<nx; ++ix)
      hf[ix] = convolve(nh,kh,h,f[ix]);
    return hf;
  }

  /**
   * Applies the bandpass filter B, if any was specified.
   * If no bandpass filter has been specified, then this method simply returns
   * a copy of the specified input sequence.
   * @param f array with input sequence f(t).
   * @return array with filtered output sequence.
   */
  public float[] applyB(float[] f) {
    float[] g = new float[f.length];
    if (_bpf!=null) {
      _bpf.apply(f,g);
    } else {
      copy(f,g);
    }
    return g;
  }

  /**
   * Applies the bandpass filter B, if any was specified.
   * If no bandpass filter has been specified, then this method simply returns
   * a copy of the specified input sequence.
   * @param f array with input sequence f(t).
   * @return array with filtered output sequence.
   */
  public float[][] applyB(float[][] f) {
    float[][] g = new float[f.length][f[0].length];
    if (_bpf!=null) {
      _bpf.apply(f,g);
    } else {
      copy(f,g);
    }
    return g;
  }

  /**
   * Applies the low-pass anti-alias filter L.
   * If the specified warping includes squeezing, then this method attenuates
   * high frequencies that could be aliased during warping.
   * @param u array of warping times u(t).
   * @param f array with input sequence f(t).
   * @return array with filtered output sequence.
   */
  public float[] applyL(float[] u, float[] f) {
    return aaf(RMAX,u,f);
  }

  public float[][] applyL(float[][] u, float[][] f) {
    return aaf(RMAX,u,f);
  }

  /**
   * Applies the warping operator S.
   * Does not apply an anti-alias low-pass filter.
   * @param u array of warping times u(t).
   * @param f array with input sequence f(t).
   * @return array with warped output sequence.
   */
  public float[] applyS(float[] u, float[] g) {
    return warp(u,g);
  }

  /**
   * Applies the warping operator S.
   * Does not apply an anti-alias low-pass filter.
   * @param u 2D array of warping times u(x,t).
   * @param f 2D array with input sequence f(x,t).
   * @return 2D array with warped output sequence.
   */
  public float[][] applyS(float[][] u, float[][] g) {
    int nx = g.length;
    int nt = g[0].length;
    float[][] sg = new float[nx][nt];
    for (int ix=0; ix<nx; ++ix) {
      sg[ix] = warp(u[ix],g[ix]);
    }
    return sg;
  }


  /**
   * Applies the composite linear operator HSLA.
   * The sequence of operations is (1) convolution with the inverse wavelet a,
   * (2) anti-alias filtering (if squeezing), (3) warping, and (4) convolution
   * with the wavelet h.
   * @param na number of samples in the inverse wavelet a.
   * @param ka the sample index for a[0].
   * @param a array of coefficients for the inverse wavelet a.
   * @param nh number of samples in the wavelet h.
   * @param kh the sample index for h[0].
   * @param h array of coefficients for the wavelet h.
   * @param u array[nt] of warping times u(t).
   * @param f array[nt] with input sequence.
   * @return array[nt] with output sequence.
   */
  public float[] applyHSLA(
    int na, int ka, float[] a,
    int nh, int kh, float[] h,
    float[] u, float[] f) 
  {
    int nt = f.length;
    float[] af = applyA(na,ka,a,f);
    float[] laf = applyL(u,af);
    float[] saf = applyS(u,laf);
    float[] hsaf = applyH(nh,kh,h,saf);
    return hsaf;
  }

  /**
   * Applies the composite linear operator HSLA.
   * The sequence of operations is (1) convolution with the inverse wavelet a,
   * (2) anti-alias filtering (if squeezing), (3) warping, and (4) convolution
   * with the wavelet h.
   * @param na number of samples in the inverse wavelet a.
   * @param ka the sample index for a[0].
   * @param a array of coefficients for the inverse wavelet a.
   * @param nh number of samples in the wavelet h.
   * @param kh the sample index for h[0].
   * @param h array of coefficients for the wavelet h.
   * @param u array[nt] of warping times u(t).
   * @param f array[nt] with input sequence.
   * @return array[nt] with output sequence.
   */
  public float[][] applyHSLA(
    int na, int ka, float[] a,
    int nh, int kh, float[] h,
    float[][] u, float[][] f) 
  {
    int nt = f.length;
    float[][] af = applyA(na,ka,a,f);
    float[][] laf = applyL(u,af);
    float[][] saf = applyS(u,laf);
    float[][] hsaf = applyH(nh,kh,h,saf);
    return hsaf;
  }


  /**
   * Applies the composite linear operator BSLA.
   * The sequence of operations is (1) convolution with the inverse wavelet a,
   * (2) anti-alias filtering (if squeezing), (3) warping, and (4) application
   * of the bandpass filter b.
   * @param na number of samples in the inverse wavelet a.
   * @param ka the sample index for a[0].
   * @param a array of coefficients for the inverse wavelet a.
   * @param u array[nt] of warping times u(t).
   * @param f array[nt] with input sequence.
   * @return array[nt] with output sequence.
   */
  public float[] applyBSLA(int na, int ka, float[] a, float[] u, float[] f)   {
    int nt = f.length;
    float[] af = applyA(na,ka,a,f);
    float[] laf = applyL(u,af);
    float[] saf = applyS(u,laf);
    float[] bsaf = applyB(saf);
    return bsaf;
  }

  /**
   * Applies the composite linear operator BSLA.
   * The sequence of operations is (1) convolution with the inverse wavelet a,
   * (2) anti-alias filtering (if squeezing), (3) warping, and (4) application
   * of the bandpass filter b.
   * @param na number of samples in the inverse wavelet a.
   * @param ka the sample index for a[0].
   * @param a array of coefficients for the inverse wavelet a.
   * @param u array[nt] of warping times u(t).
   * @param f array[nt] with input sequence.
   * @return array[nt] with output sequence.
   */
  public float[][] applyBSLA(int na, int ka, float[] a, 
    float[][] u, float[][] f) {
    int nt = f.length;
    float[][] af = applyA(na,ka,a,f);
    float[][] laf = applyL(u,af);
    float[][] saf = applyS(u,laf);
    float[][] bsaf = applyB(saf);
    return bsaf;
  }

  /**
   * Applies the composite linear operator BSLA.
   * The sequence of operations is (1) convolution with the inverse wavelet a,
   * (2) anti-alias filtering (if squeezing), (3) warping, and (4) application
   * of the bandpass filter b.
   * @param na number of samples in the inverse wavelet a.
   * @param ka the sample index for a[0].
   * @param a array of coefficients for the inverse wavelet a.
   * @param u array[nt] of warping times u(t).
   * @param f array[nt] with input sequence.
   * @return array[nt] with output sequence.
   */
  public float[][] applySLA(int na, int ka, float[] a, 
    float[][] u, float[][] f) {
    int nt = f.length;
    float[][] af = applyA(na,ka,a,f);
    float[][] laf = applyL(u,af);
    float[][] saf = applyS(u,laf);
    return saf;
  }

  public float[] applyBA(int na, int ka, float[] a, float[] f) {
    int nt = f.length;
    float[] af = applyA(na,ka,a,f);
    float[] baf = applyB(af);
    return baf;
  }

  public float[][] applyBA(int na, int ka, float[] a, float[][] f) {
    int nt = f.length;
    float[][] af = applyA(na,ka,a,f);
    float[][] baf = applyB(af);
    return baf;
  }

  public float[][] applyBSL(int na, int ka, float[] a, 
    float[][] u, float[][] f) {
    int nt = f.length;
    float[][] lf = applyL(u,f);
    float[][] slf = applyS(u,lf);
    float[][] bslf = applyB(slf);
    return bslf;
  }


  /**
   * Creates the warped times from the necessary shifts.
   *@param h array of shfits in samples.
   */
   public float[] getWarpedSamples(Sampling sg, float[] h) {
     int ng = sg.getCount();
     int nh = h.length;
     Sampling s1 = new Sampling(nh);
     int n1 = s1.getCount();
     float[] u = new float[n1];
     for (int i1=0; i1<n1; ++i1) 
       u[i1] = (float)s1.getValue(i1)+h[i1];
     return u;
   }

  /**
   * Creates the warped times from the necessary shifts.
   *@param h array of shfits in samples.
   */
   public float[][] getWarpedSamples(Sampling sg, float[][] h) {
     int nx = h.length; 
     int ng = sg.getCount();
     int nh = h[0].length;
     Sampling s1 = new Sampling(nh);
     int n1 = s1.getCount();
     float[][] u = new float[nx][n1];
     for (int ix=0; ix<nx; ++ix) {
       for (int i1=0; i1<n1; ++i1) 
         u[ix][i1] = (float)s1.getValue(i1)+h[ix][i1];
     }
     return u;
   }
   
   /**
    * Computes the variance with a mean of zero
    */
    public float getVarianceEnhancedWarp(
      int na, int ka, float[] a, Sampling sft, Sampling sx, 
      float[][] u, float[][] g, float[][] f)
    {
      float[][] bslga = applyBSLA(na,ka,a,u,g);
      float[][] bfa = applyBA(na,ka,a,f);
      return pow(rms(sub(bslga,bfa)),2.0f);
    }

   /**
    * Computes the variance with a mean of zero
    */
    public float getVarianceRegularWarp(
      int na, int ka, float[] a, Sampling sft, Sampling sx, 
      float[][] u, float[][] g, float[][] f)
    {
      float[][] lg = applyL(u,g);
      float[][] slg = applyS(u,lg);
      return pow(rms(sub(slg,f)),2.0f);
    }

   /**
    * Plot the gathers that are used in computeDifferences
    * For debugging
    */
    public void plotDiffGathers(Sampling sx, Sampling sft, Sampling sgt, 
      int itminf, int itmaxf, int itming, int itmaxg, 
      int ixmin, int ixmax, float amax, int na, int ka, 
      boolean df, boolean dg, boolean ldg, boolean sldg, 
      boolean d, boolean bd) 
    {
      float dt = (float)sft.getDelta();
      String titledf = "df";
      String titledg = "dg";
      String titleldg = "ldg";
      String titlesldg = "sldg";
      String titled = "d";
      String titlebd = "bd";
      String title = " ";
      int lag = 0;
      for (int ia=0; ia<na; ++ia) {
        lag = ka+ia;
        title = titledf+" "+lag;
        if (df) plotGather(sx,sft,_df[ia],itminf,itmaxf,ixmin,ixmax,amax,title);
        title = titledg+" "+lag;
        if (dg) plotGather(sx,sgt,_dg[ia],itming,itmaxg,ixmin,ixmax,amax,title);
        title = titleldg+" "+lag;
        if (ldg) plotGather(sx,sgt,_ldg[ia],itming,itmaxg,ixmin,ixmax,amax,title);
        title = titlesldg+" "+lag;
        if (sldg) plotGather(sx,sft,_sldg[ia],itminf,itmaxf,ixmin,ixmax,amax,title);
        title = titled+" "+lag;
        if (d) plotGather(sx,sft,_d[ia],itminf,itmaxf,ixmin,ixmax,amax,title);
        title = titlebd+" "+lag;
        if (bd) plotGather(sx,sft,_bd[ia],itminf,itmaxf,ixmin,ixmax,amax,title);
      }
    }

   /**
    * Plot the gathers that are used in computeDifferences
    * For debugging
    */
    public void plotDiffGathers(Sampling sx, Sampling sft, Sampling sgt, 
      int ia, int itminf, int itmaxf, int itming, int itmaxg, 
      int ixmin, int ixmax, float amax, int na, int ka,
      boolean df, boolean dg, boolean ldg, boolean sldg,
      boolean d, boolean bd) 
    {
      float dt = (float)sft.getDelta();
      String titledf = "df";
      String titledg = "dg";
      String titleldg = "ldg";
      String titlesldg = "sldg";
      String titled = "d";
      String titlebd = "bd";
      String title = " ";
      int lag = 0;
      lag = ka+ia;
      title = titledf+" "+lag;
      if (df) plotGather(sx,sft,_df[ia],itminf,itmaxf,ixmin,ixmax,amax,title);
      title = titledg+" "+lag;
      if (dg) plotGather(sx,sgt,_dg[ia],itming,itmaxg,ixmin,ixmax,amax,title);
      title = titleldg+" "+lag;
      if (ldg) plotGather(sx,sft,_ldg[ia],itminf,itmaxf,ixmin,ixmax,amax,title);

      title = titlesldg+" "+lag;
      if (sldg) plotGather(sx,sft,_sldg[ia],itminf,itmaxf,ixmin,ixmax,amax,title);
      title = titled+" "+lag;
      if (d) plotGather(sx,sft,_d[ia],itminf,itmaxf,ixmin,ixmax,amax,title);
      title = titlebd+" "+lag;
      if (bd) plotGather(sx,sft,_bd[ia],itminf,itmaxf,ixmin,ixmax,amax,title);
    }

   /**
    * Plot one trace that is apart of the gathers used in computeDifferences
    * For debugging
    */
    public void plotDiffTraces(Sampling sx, Sampling sf, Sampling sg, 
      int itminf, int itmaxf, int itming, int itmaxg, int ix, float amax, 
      int na, int ka, boolean df, boolean dg, boolean ldg, 
      boolean sldg, boolean d, boolean bd) 
    {
      float dt = (float)sf.getDelta();
      float xval = (float)sx.getValue(ix);
      String titledf = "df";
      String titledg = "dg";
      String titleldg = "ldg";
      String titlesldg = "sldg";
      String titled = "d";
      String titlebd = "bd";
      String title = " ";
      int lag = 0;
      for (int ia=0; ia<na; ++ia) {
        lag = ka+ia;
        title = titledf+" x = "+xval+" lag = "+lag;
        if (df) plotTrace(sf,_df[ia][ix],itminf,itmaxf,amax,title);
        title = titledg+" x = "+xval+" lag = "+lag;
        if (dg) plotTrace(sg,_dg[ia][ix],itming,itmaxg,amax,title);
        title = titleldg+" x = "+xval+" lag = "+lag;
        if (ldg) plotTrace(sf,_ldg[ia][ix],itminf,itmaxf,amax,title);
        title = titlesldg+" x = "+xval+" lag = "+lag;
        if (sldg) plotTrace(sf,_sldg[ia][ix],itminf,itmaxf,amax,title);
        title = titled+" x = "+xval+" lag = "+lag;
        if (d) plotTrace(sf,_d[ia][ix],itminf,itmaxf,amax,title);
        title = titlebd+" x = "+xval+" lag = "+lag;
        if (bd) plotTrace(sf,_bd[ia][ix],itminf,itmaxf,amax,title);
      }
    }

   /**
    * Plot one trace that is apart of the gathers used in computeDifferences
    * For debugging
    */
    public void plotDiffTraces(
      Sampling sx, Sampling sf, Sampling sg, 
      int itminf, int itmaxf, int itming, int itmaxg, int ix, float amax, 
      int na, int ka, int ia, boolean df, boolean dg, 
      boolean ldg, boolean sldg, boolean d, boolean bd) 
    {
      float dt = (float)sf.getDelta();
      float xval = (float)sx.getValue(ix);
      String titledf = "df";
      String titledg = "dg";
      String titleldg = "ldg";
      String titlesldg = "sldg";
      String titled = "d";
      String titlebd = "bd";
      String title = " ";
      int lag = 0;
      lag = ka+ia;
      title = titledf+" x = "+xval+" lag = "+lag;
      if (df) plotTrace(sf,_df[ia][ix],itminf,itmaxf,amax,title);
      title = titledg+" x = "+xval+" lag = "+lag;
      if (dg) plotTrace(sg,_dg[ia][ix],itming,itmaxg,amax,title);
      title = titleldg+" x = "+xval+" lag = "+lag;
      if (ldg) plotTrace(sf,_ldg[ia][ix],itminf,itmaxf,amax,title);
      title = titlesldg+" x = "+xval+" lag = "+lag;
      if (sldg) plotTrace(sf,_sldg[ia][ix],itminf,itmaxf,amax,title);
      title = titled+" x = "+xval+" lag = "+lag;
      if (d) plotTrace(sf,_d[ia][ix],itminf,itmaxf,amax,title);
      title = titlebd+" x = "+xval+" lag = "+lag;
      if (bd) plotTrace(sf,_bd[ia][ix],itminf,itmaxf,amax,title);
    }


  /////////////////////////////////////////////////////////////////////////
  // private

  private static final float RMAX = 10.0f; // limits anti-alias filter
  private static final SincInterp _si = 
    SincInterp.fromErrorAndFrequency(0.01,0.40);

  private double _sfac = 1.0;
  private int _itmin = -1;
  private int _itmax = -1;
  private int _ixmin = -1;
  private int _ixmax = -1;
  private BandPassFilter _bpf;
  private float _r;
  private float[][][] _df, _dg, _ldg, _sldg, _d, _bd;

  /**
   * Returns the array of differences D = B(SLG-F).
   */
  private float[][] computeDifferences(
    int na, int ka, float[] u, float[] f, float[] g)
  {
    g = applyL(u,g);
    
    int nt = u.length;
    float[][] d = new float[na][];
    for (int ia=0,lag=ka; ia<na; ++ia,++lag) {
      float[] df = delay(lag,f);
      float[] dg = delay(lag,g);
      float[] sdg = applyS(u,dg);
      float[] di = sub(sdg,df);
      d[ia] = di;
      d[ia] = applyB(di);
      
    }

    return d;
  }

  private float[][][] computeDifferences(
    int na, int ka, float[][] u, float[][] f, float[][] g)
  {
    
    int nt = u.length;
    float[][][] d = new float[na][][];

    g = applyL(u,g);
    for (int ia=0,lag=ka; ia<na; ++ia,++lag) {
      float[][] df = delay(lag,f);
      float[][] dg = delay(lag,g);
      float[][] sdg = applyS(u,dg);
      float[][] di = sub(sdg,df);
      d[ia] = applyB(di);
      
    }
    return d;
  }

  private float[][] computeDifferencesIter(
    int na, int ka, int nh, int kh, float[] h, 
    float[] u, float[] f, float[] g)
  {
    
    g = applyL(u,g);
    int nt = u.length;
    float[][] d = new float[na][];
    for (int ia=0,lag=ka; ia<na; ++ia,++lag) {
      float[] df = delay(lag,f);
      float[] dg = delay(lag,g);
      float[] sdg = applyS(u,dg);
      float[] di = sub(sdg,df);
      d[ia] = applyH(nh,kh,h,di);
      
      
    }
    return d;
  }

  private float[][][] computeDifferencesIter(
    int na, int ka, int nh, int kh, float[] h, 
    float[][] u, float[][] f, float[][] g)
  {
    
    g = applyL(u,g);
    int nt = u.length;
    float[][][] d = new float[na][][];

    for (int ia=0,lag=ka; ia<na; ++ia,++lag) {
      float[][] df = delay(lag,f);
      float[][] dg = delay(lag,g);
      float[][] sdg = applyS(u,dg);
      float[][] di = sub(sdg,df);
      d[ia] = applyH(nh,kh,h,di);
      
    }
    return d;
  }

  private float[][] computeZ(
    int na, int ka, int nh, int kh, float[] h, 
    float[] u, float[] f, float[] g)
  {
    
    int nt = u.length;
    float[][] z = new float[na][];

    for (int ia=0,lag=ka; ia<na; ++ia,++lag) {
      float[] dg = delay(lag,g);
      float[] ldg = applyL(u,dg);
      float[] sldg = applyS(u,ldg);
      z[ia] = applyH(nh,kh,h,sldg);
    }
    return z;
  }

  private float[][][] computeZ(
    int na, int ka, int nh, int kh, float[] h, 
    float[][] u, float[][] f, float[][] g)
  {
    
    int nt = u.length;
    float[][][] d = new float[na][][];

    for (int ia=0,lag=ka; ia<na; ++ia,++lag) {
      float[][] dg = delay(lag,g);
      float[][] ldg = applyL(u,dg);
      float[][] sldg = applyS(u,ldg);
      d[ia] = applyH(nh,kh,h,sldg);
    }
    return d;
  }

  private float[][] computeP(
    int na, int ka, int nh, int kh, float[] h, 
    float[] u, float[] f, float[] g)
  {
    
    int nt = u.length;
    float[][] p = new float[na][];

    for (int ia=0,lag=ka; ia<na; ++ia,++lag) {
      float[] dg = delay(lag,g);
      float[] ldg = applyL(u,dg);
      float[] sldg = applyS(u,ldg);
      p[ia] = applyH(nh,kh,h,sldg);
    }
    return p;
  }

  private float[][][] computeP(
    int na, int ka, int nh, int kh, float[] h, 
    float[][] u, float[][] f, float[][] g)
  {
    
    int nt = u.length;
    float[][][] p = new float[na][][];

    for (int ia=0,lag=ka; ia<na; ++ia,++lag) {
      float[][] dg = delay(lag,g);
      float[][] ldg = applyL(u,dg);
      float[][] sldg = applyS(u,ldg);
      p[ia] = applyH(nh,kh,h,sldg);
    }
    return p;
  }

  private double dot(float[] x, float[] y) {
    int nt = x.length;
    int itlo = (_itmin<_itmax)?_itmin:0;
    int ithi = (_itmin<_itmax)?_itmax:nt-1;
    double sum = 0.0;
    for (int it=itlo; it<=ithi; ++it) 
      sum += x[it]*y[it];
    return sum;
  }


  private double dot(float[][] x, float[][] y) {
    int nt = x[0].length;
    int nx = x.length;
    int itlo = (_itmin<_itmax)?_itmin:0;
    int ithi = (_itmin<_itmax)?_itmax:nt-1;
    int ixlo = (_ixmin<_ixmax)?_ixmin:0;
    int ixhi = (_ixmin<_ixmax)?_ixmax:nx-1;
    double sum = 0.0;
    for (int ix=ixlo; ix<ixhi; ++ix) 
      for (int it=itlo; it<=ithi; ++it) 
        sum += x[ix][it]*y[ix][it];
    return sum;
  }

  /**
   * Returns the largest squeezing r(t) = u'(t) not greater than rmax.
   * If less than or equal to one, then no squeezing is implied by u(t).
   */
  private float squeezing(float rmax, float[] u) {
    int nt = u.length;
    int itlo = max(1,_itmin);
    int ithi = min(_itmax,nt-1);
    float r = 0.0f;
    for (int it=itlo; it<=ithi; ++it) {
      float du = u[it]-u[it-1];
      if (r<du)
        r = du;
    }
    return min(r,rmax);
  }

  /**
   * Returns the largest squeezing r(t) = u'(t) not greater than rmax.
   * If less than or equal to one, then no squeezing is implied by u(t).
   */
  private float squeezing(float rmax, float[][] u) {
    int nt = u[0].length;
    int nx = u.length;
    int itlo = max(1,_itmin);
    int ithi = min(_itmax,nt-1);
    int ixlo = max(0,_ixmin);
    int ixhi = min(_ixmax,nx-1);
    float r = 0.0f;
    for (int ix=ixlo; ix<ixhi; ++ix) {
      for (int it=itlo; it<=ithi; ++it) {
        float du = u[ix][it]-u[ix][it-1];
        if (r<du)
          r = du;
      }
    }
    return min(r,rmax);
  }

  /**
   * If necessary, applies an anti-alias filter to the sequence x(t).
   * An anti-alias filter is necessary if the warping includes squeezing.
   */
  private float[] aaf(float rmax, float[] u, float[] x) {
    int nt = x.length;

    //float r = squeezing(RMAX,u);
    float r = _r;
    if (r>1.0) {
      float[] y = new float[nt];
      BandPassFilter aaf = new BandPassFilter(0.0,0.5/r,0.10/r,0.01);
      aaf.apply(x,y);
      return y;
    } else {
      return copy(x);
    }
  }

  /**
   * Set the upper bounds on the squeeze factor that is applied
   * in the data.
   */
  public void setR(float r) {
    _r = r;
  }

  /**
   * If necessary, applies an anti-alias filter to the sequence x(t).
   * An anti-alias filter is necessary if the warping includes squeezing.
   */
  private float[][] aaf(float rmax, float[][] u, float[][] x) {
    int nt = x[0].length;
    int nx = x.length;
    //float r = squeezing(RMAX,u);
    float r = _r;
    if (r>1.0) {
      float[][] y = new float[nx][nt];
      BandPassFilter aaf = new BandPassFilter(0.0,0.5/r,0.10/r,0.01);
      aaf.apply(x,y);
      return y;
    } else {
      return copy(x);
    }
  }

  /**
   * Returns y(x,t) = x(x,t-lag).
   */
  private static float[][] delay(int lag, float[][] x) {
    int nt = x[0].length;
    int nx = x.length;
    int itlo = max(0,lag);   // 0 <= it-lag
    int ithi = min(nt,nt+lag); // it-lag < nt
    float[][] y = new float[nx][nt];
    for (int ix=0; ix<nx; ++ix) {
      for (int it=0; it<itlo; ++it)
        y[ix][it] = 0.0f;
      for (int it=itlo; it<ithi; ++it)
        y[ix][it] = x[ix][it-lag];
      for (int it=ithi; it<nt; ++it)
        y[ix][it] = 0.0f;
    }
    return y;
  }

  /**
   * Returns y(t) = x(t-lag).
   */
  private static float[] delay(int lag, float[] x) {
    int nt = x.length;
    int itlo = max(0,lag);   // 0 <= it-lag
    int ithi = min(nt,nt+lag); // it-lag < nt
    float[] y = new float[nt];
    for (int it=0; it<itlo; ++it)
      y[it] = 0.0f;
    for (int it=itlo; it<ithi; ++it)
      y[it] = x[it-lag];
    System.out.println("ithi = "+ithi);
    for (int it=ithi; it<nt; ++it)
      y[it] = 0.0f;
    return y;
  }

  /**
   * Returns y(t) = x(u(t)).
   */
  private static float[] warp(float[] u, float[] x) {
    int ntIn = x.length;
    int ntOut = u.length;
    float[] y = new float[ntOut];
    _si.interpolate(ntIn,1.0,0.0,x,ntOut,u,y);
    y[0] *= u[1]-u[0];
    for (int it=1; it<ntOut; ++it)
      y[it] *= u[it]-u[it-1];
    return y;
  }


  /**
   * Returns y(t) = h(t)*x(t), where * denotes convolution.
   */
  private static float[] convolve(int nh, int kh, float[] h, float[] x) {
    int nt = x.length;
    float[] y = new float[nt];
    convolve(nh,kh,h,x,y);
    return y;
  }

  /**
   * Returns y(t) = h(t)*x(t), where * denotes convolution.
   */
  private static float[][] convolve(int nh, int kh, float[] h, float[][] x)   {
    int nt = x.length;
    int nx = x[0].length;
    float[][] y = new float[nx][nt];
    for (int ix=0; ix<nx; ++ix) 
      convolve(nh,kh,h,x[ix],y[ix]);
    return y;
  }

  private static void convolve(
    int nh, int kh, float[] h, float[] f,  float[] g)
  {
    int nt = f.length;
    conv(nh,kh,h,nt,0,f,nt,0,g);
  }

  private float rms(float[] x) {
    int nt = x.length;
    return (float)sqrt(dot(x,x)/nt);
  }

  /**
   * Plot Gathers
   */
  private void plotGather(Sampling sx, Sampling sf, float[][] x,
    int itmin, int itmax, int ixmin, int ixmax, float amax, String title) 
  {
    SimplePlot sp = new SimplePlot(SimplePlot.Origin.UPPER_LEFT);
    double dt = sf.getDelta();
    double dx = sx.getDelta();
    sp.setVLimits((double)itmin*dt,(double)itmax*dt);
    sp.setHLimits((double)ixmin*dx,(double)ixmax*dx);
    sp.setTitle(title);
    sp.addColorBar();

    PixelsView pv = sp.addPixels(sf,sx,x);
    pv.setClips(-amax,amax);
  }

  /**
   * Plot Traces
   */
  private void plotTrace(Sampling sf, float[] x,
    float itmin, float itmax, float amax, String title) 
  {
    SimplePlot sp = new SimplePlot(SimplePlot.Origin.UPPER_LEFT);
    double dt = sf.getDelta();
    sp.setVLimits((double)itmin*dt,(double)itmax*dt);
    sp.setTitle(title);

    PointsView pv = sp.addPoints(sf,x);
    sp.setHLimits(-amax,amax);
  }

  private float rms(float[][] f) {
    int nt = f[0].length;
    int nx = f.length;
    return (float)(sqrt(dot(f,f)/nx/nt));
  }
}


  


