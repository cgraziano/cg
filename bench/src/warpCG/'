from imports import *
from dwarp import DynamicWarpingW 

datadir = "C:/Users/Chris/Documents/CWP/Research/research/gbc/dat"
pngDir = "./png/balancetest/"
#pngDir = None

def main(args):
  #Available Options: pp, ps1, ps2, shiftl, shiftc
  pp = "pp"
  ps = "ps1"
  shift = "shiftl"
  iline = 70 
  ka = 0 
  na = 10
  kh = -125
  nh = 251


  pp = getData(pp,iline)
  ps = getData(ps,iline)
  #pp = balance(8.0,pp)
  shift = getData(shift,iline)
  stpp = Sampling(2000,.002,0.0)
  stps = Sampling(2000,.002,0.0)
  sx = Sampling(145,0.033529,0.0)
  ###################################d#
  #balanceCheck(iline, sx, stpp, stps, pp, ps, shift)
  balanceCheckS(iline, sx, stpp, stps, pp, ps, shift, 80, 80)
  #testInverse(ka, na, kh, nh, stpp, stps, sx, pp, ps, shift)
  

def testInverse(ka, na, kh, nh, stpp, stps, sx, pp, ps, shift):
  fmin = 5
  fmax = 85
  dt = stpp.delta
  bpf = None#BandPassFilter(fmin*dt,fmax*dt,0.05,0.01)
  dww = DynamicWarpingW()
  dww.setStabilityFactor(1.01)
  dww.setFrequencyRange(5*dt, 85*dt)
  dww.setTimeRange(400,1500)
  pp = balance(100,pp)
  ps = balance(100,ps)
  a = dww.getInverseAWarp(na, ka, 
      stpp, stps, sx, shift, pp, ps)
  #plotSlice(stps,sx,ps,tmin=.6,tmax=.8,title="ps")
  #plotSlice(stps,sx,ps,tmin=0.0,tmax=3.998,title="ps")
  #h = dww.getWaveletH(na, ka, a, nh, kh)
  #SimplePlot.asPoints(h)
  print "Inverse Wavelet Coefficients:"
  dump(a)
  #plotSlice(stps,sx,aps,tmin=0.0,tmax=3.998,title="aps")


def balanceCheck(iline, sx, stpp, stps, pp, ps, shift):
  print "Available Options: pp, ps1, ps2, shiftl, shiftc"
  #plotSlice(stps,sx,ps,tmin=0.0,tmax=2.8,title="ps")
  #plotSlice(stpp,sx,ps,tmin=0.0,tmax=3.998,title="balps")
  fsigpp = 0
  dsigpp = 10
  maxsigpp = 100
  nsigpp = maxsigpp/dsigpp
  sigpp = fsigpp
  fsigwarp = 0
  dsigwarp = 10
  maxsigwarp = 100
  nsigwarp = maxsigwarp/dsigwarp
  sigwarp = fsigwarp
  count = 0
  while(sigpp<=maxsigpp):
    while(sigwarp<=maxsigwarp):
      dww = DynamicWarpingW()
      if sigpp!=0:
        pp = sexp(pp)
        #pp = balance(sigpp,pp)
      warp = dww.applyShifts(stps,ps,shift)
      if sigwarp!=0:
        #warp = balance(sigwarp,warp)
        warp = sexp(warp)
      #print "ppsig = "+str(sigpp)+" warpsig = "+str(sigwarp)
      #print "max of pp = "+str(max(pp))+" min of pp = "+str(min(pp))
      #print "max of warp = "+str(max(warp))+" min of warp= "+str(min(warp))
      
      title = "ppps\c"+str(count)+"PP "+str(sigpp)
      plotSlice(stpp,sx,pp,tmin=0.6,tmax=2.5,title=title,pngDir=pngDir)
      title = "ppps\c"+str(count)+"PS "+str(sigwarp)
      plotSlice(stpp,sx,warp,tmin=0.6,tmax=2.5,title=title,pngDir=pngDir)
      #d = sub(warp,pp)
      #titleD = "d\c"+str(count)+"Difference PP Sig = "+str(sigpp)\
      #+" Warp Sig = "+str(sigwarp)
      #plotSlice(stpp,sx,d,tmin=0.6,tmax=2.5,title=titleD,pngDir=pngDir)
      sigwarp += dsigwarp
      count += 1
    sigwarp = fsigwarp
    sigpp += dsigpp
  """n = 100
  impulse = zerofloat(n)
  impulse[3*n/4] = 1.0
  impulse[n/2] = 10.0
  impulse[n/4] = 100.0
  SimplePlot.asPoints(impulse)
  impulse = balance(8,impulse)
  SimplePlot.asPoints(impulse)
  """
  perc = 100 
  #plotSlice(stpp,sx,warp,tmin=0.6,tmax=2.2,perc=perc,title="warpb")
  #plotSlice(stpp,sx,pp,tmin=0.6,tmax=2.2,title="pp")
  #plotSlice(stpp,sx,pp,tmin=0.6,tmax=2.2,perc=perc,title="ppb")
  #plotSlice(stpp,sx,d,tmin=0.6,tmax=2.2,perc=perc,title="d")

def balanceCheckS(iline, sx, stpp, stps, pp, ps, shift, sigpp, sigwarp):
  print "Available Options: pp, ps1, ps2, shiftl, shiftc"
  dww = DynamicWarpingW()
  print "sigpp = "+str(sigpp)+" sigps = "+str(sigwarp)
  #print "rms pp = "+str(dww.rms(stpp,sx,0.5,2.6,pp))
  plotSlice(stpp,sx,pp,tmin=0.5,tmax=2.4,amax=9,title="pp")
  if sigpp!=0:
    pp = balance(sigpp,pp)
    #pp = sexp(pp)
  print "balance rms pp = "+str(dww.rms(stpp,sx,0.5,2.4,pp))
  plotSlice(stpp,sx,pp,tmin=0.5,tmax=2.4,amax=7,title="bpp")

  #print "rms ps = "+str(dww.rms(stps,sx,0.7,3.5,ps))
  #print "rms warp = "+str(dww.rms(stpp,sx,0.5,2.6,warp))
  plotSlice(stps,sx,ps,tmin=0.5,tmax=3.4,amax=7,title="ps")
  if sigwarp!=0:
    ps = balance(sigwarp,ps)
    #ps = sexp(ps)

  warp = dww.applyShifts(stps,ps,shift)
  print "balance rms warp = "+str(dww.rms(stpp,sx,0.5,2.4,warp))
  plotSlice(stpp,sx,warp,tmin=0.5,tmax=2.4,amax=7,title="bwarp")

  d = sub(warp,pp)
  plotSlice(stpp,sx,d,tmin=0.5,tmax=2.4,amax=7,title="d")
  print "rms d = "+str(dww.rms(stpp,sx,0.5,2.4,d))

  #titleD = "Difference PP Sig = "+str(sigpp)+" Warp Sig = "+str(sigwarp)
  

def getData(data,il=None):
  if data == "pp":
    f = readImage(datadir+"/pp.dat",2000,150,145)
  elif data == "ps1":
    f = readImage(datadir+"/ps1.dat",2000,150,145)
  elif data == "ps2":
    f = readImage(datadir+"/ps2.dat",2000,150,145)
  elif data == "shiftl":
    f = readImage(datadir+"/u_sag_linear.dat",2000,150,145)
  elif data == "shiftc":
    f = readImage(datadir+"/u_sag_monotonic.dat",2000,150,145)

  if il:
    inline = zerofloat(2000,145)
    for i3 in range(0,145):
      for i1 in range(0,2000):
        inline[i3][i1] = f[il][i3][i1]
    #sp = SimplePlot(SimplePlot.Origin.UPPER_LEFT)
    #sp.addPixels(inline)
    
    
    return inline 
  else:
    #sf = SimpleFrame.asImagePanels(f)
    return f

def readImage(fileName,n1,n2,n3=1):
  if n3==1:
    x = zerofloat(n1,n2)
  else:
    x = zerofloat(n1,n2,n3)
  ais = ArrayInputStream(fileName)
  ais.readFloats(x)
  ais.close()
  return x

def plotSlice(st,sx,p,tmin=None,tmax=None,amin=None,amax=None,
    title=None,pngDir=None):
  sp = SimplePlot(SimplePlot.Origin.UPPER_LEFT)
  if title:
    if pngDir==None:
      sp.setTitle(title)
  sp.setHLabel("Offset (km)")
  sp.setVLabel("Time (s)")
  sp.setSize(400,750)
  sp.addColorBar()
  if tmin!=None and tmax!=None:
    sp.setVLimits(tmin,tmax)
  pv = sp.addPixels(st,sx,p)
  pv.setColorModel(ColorMap.getRedWhiteBlue())
  if amax:
    if amin:
      pv.setClips(amin,amax)
    else:
      pv.setClips(-amax,amax)
  if pngDir:
    sp.paintToPng(1000,5,pngDir+title+".png")

def balance(sigma,f):
  f = add(max(f)*0.00001,f)
  ff = mul(f,f)
  RecursiveExponentialFilter(sigma).apply1(ff,ff)
  return div(f,sqrt(ff))

def sexp(x):
  return mul(sgn(x),log(add(abs(x),1.0)))



#############################################################################
# Do everything on Swing thread.

class RunMain(Runnable):
  def run(self):
    main(sys.argv)
SwingUtilities.invokeLater(RunMain())

