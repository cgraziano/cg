from imports import *
from edu.mines.jtk.dsp.Conv import *
from dwarp import Warp, DynamicWarpingW 
from testing import Synthetic
from linalgebra import ToeplitzRecursion

pngDir = "./png/synthetic/"
#pngDir = None

def main(args):
  na = 3
  ka = 0
  nh = 250
  kh = -125
  nt = 500
  dt = .002
  ft = 0
  mt = 0#time when mute time ends
  t = .2,.5,1.09
  a = 2,2,2
  na = len(a)
  ci = CubicInterpolator(CubicInterpolator.Method.MONOTONIC,na,t,a)
  a = ci.interpolate(rampfloat(ft,dt,nt))
  #SimplePlot.asPoints(a)

  st = Sampling(nt,dt,ft)
  nref = 2 
  tref = .2,.5
  aref = 1,.5
  freq,decay = 50.0,0.05
  hp,ampshp,shifts,at = syntheticTracesTrefSHP(st,mt,a,
    tref,aref,freq,decay,plot=True)
  shifts = getInverseTimeShifts(st,a,ampshp,shifts)
  #estimateInvWavelet(st,hp,ampshp,shifts,na,ka,nh,kh)

def estimateInvWavelet(st, f, g, shifts, na, ka, nh, kh):
  dt = st.getDelta()
  odt = 1.0/dt
  warp = Warp()
  dww = DynamicWarpingW(warp)
  dww.setTimeRange(int(.15*odt),int(.7*odt))
  dww.setStabilityFactor(1.00)
  dww.setFrequencyRange(5*dt,85*dt)
  a = dww.getInverseAWarp(na,ka,st,st,shifts,f,g)
  h = dww.getWaveletH(na,ka,a,nh,kh)
  print a
  plotWavelets(Sampling(nh,st.getDelta(),kh*st.getDelta()),[h],title="Estimated Wavelet",)

def getInverseTimeShifts(st, a, ampshp, shifts):
  oa = div(1.0,a)
  t,u,shifts = createWarpedTime(st,oa)
  #To check inverse time shifts
  #warp = Warp()
  #sshp = warp.applyShifts(st,ampshp,shifts)#apply warping
  #amp = Warp.getAmplitudes(st,100,ampshp,u)#calculate amp correction
  #ampsshp = mul(amp,sshp)
  #sp2 = SimplePlot()
  #sp2.addPoints(ampsshp)
  #sp2.addTitle("ampsshp")
  return shifts
  
def syntheticTracesTrefSHP(st, mt, a, tref, aref, freq, decay, plot=None):
  nt = st.getCount()
  p = Synthetic.makeTraceTRef(st,mt,tref,aref)
  hp = zerofloat(nt)
  
  hp = addArWavelet(freq,decay,st,p)

  t,u,shifts = createWarpedTime(st,a)

  dt = st.getDelta()
  odt = 1.0/dt

  a = zerofloat(nt)
  for i in range(1,nt):
    a[i] = (u[i]-u[i-1])*odt
  #   print "a[",i,"] = "+str(a[i])
  a[0] = a[1]

  warp = Warp()
  #shp = warp.applyShifts(st,hp,shifts)#apply warping
  #amp = DynamicWarpingW.getAmplitudes(st,100,hp,u)#calculate amp correction
  #ampshp = mul(amp,shp)
  ampshp = warp.applyTest(st,shifts,hp)
  
  if plot:
    #look at outputs
    plotTrace(st,hp,0,0.998,3,"hp")
    plotTrace(st,ampshp,0,0.998,3,"ampshp")

  #Can get back to original trace?
  #shifts = getInverseTimeShifts(st,a,ampshp,shifts)
  #warp = Warp()
  #ampsshp= warp.apply(st,shifts,ampshp)
  #sp1 = SimplePlot()
  #sp1.addPoints(ampsshp)
  #sp1.addTitle("ampSshp")

  return hp,ampshp,shifts,a

def syntheticTracesSHP(st, mt, a, nref, freq, decay):
  nt = st.getCount()
  p = Synthetic.makeTrace(st,mt,nref)
  hp = zerofloat(nt)
  
  hp = addArWavelet(freq,decay,st,p)
  
  #create "new" time and the corresponding shifts to get this time
  t,u,shifts = createWarpedTime(st,a)

  dt = st.getDelta()
  odt = 1.0/dt

  a = zerofloat(nt)
  for i in range(1,nt):
    a[i] = (u[i]-u[i-1])*odt
  #   print "a[",i,"] = "+str(a[i])
  a[0] = a[1]

  warp = Warp()
  #shp = warp.applyShifts(st,hp,shifts)#apply warping
  #amp = DynamicWarpingW.getAmplitudes(st,100,hp,u)#calculate amp correction
  #ampshp = mul(amp,shp)
  ampshp = warp.apply(st,shifts,hp)
  
  #look at outputs
  #sp = SimplePlot()
  #sp.addPoints(hp)
  #sp.addTitle("hp")
  #sp1 = SimplePlot()
  #sp1.addPoints(ampshp)
  #sp1.addTitle("ampshp")

  #Can get back to original trace?
  #shifts = getInverseTimeShifts(st,a,ampshp,shifts)
  #warp = Warp()
  #ampsshp= warp.apply(st,shifts,ampshp)
  #sp1 = SimplePlot()
  #sp1.addPoints(ampsshp)
  #sp1.addTitle("ampSshp")

  return hp,ampshp,shifts,a

def plotDifferenceGathers(dww, na, ka, stf, stg, sx, shifts, f, g):
  d = dww.getDifferenceGathers(na,ka,stf,stg,sx,shifts,f,g)
  lag = ka
  for ia in range(0,na):
    title = "d lag = "+str(lag)
    plotSlice(stf,sx,d[ia],tmin=0.5,tmax=2.4,amax=6,title=title)
    lag += 1

def addArWavelet(fpeak,decay,st,p,zp=False):
  r = exp(-decay)
  w = 2.0*PI*fpeak*st.delta
  a1,a2 = -2.0*r*cos(w),r*r
  print "a1 =",a1," a2 =",a2
  poles = [Cdouble.polar(r,w),Cdouble.polar(r,-w)]
  zeros = []
  gain = 1.0
  if zp:
    gain *= sqrt(1.0+a1*a1+a2*a2)
  x = copy(p)
  t = copy(p)
  rcf = RecursiveCascadeFilter(poles,zeros,gain)
  rcf.applyForward(p,t)
  if zp:
    rcf.applyReverse(t,x)
  else:
    copy(t,x)
  return x


def getData(data,il=None):
  if data == "pp":
    f = readImage(datadir+"/pp.dat",2000,150,145)
  elif data == "ps1":
    f = readImage(datadir+"/ps1.dat",2000,150,145)
  elif data == "ps2":
    f = readImage(datadir+"/ps2.dat",2000,150,145)
  elif data == "shiftl":
    f = readImage(datadir+"/u_sag_linear.dat",2000,150,145)
  elif data == "shiftc":
    f = readImage(datadir+"/u_sag_monotonic.dat",2000,150,145)

  if il:
    inline = zerofloat(2000,145)
    for i3 in range(0,145):
      for i1 in range(0,2000):
        inline[i3][i1] = f[il][i3][i1]
    #sp = SimplePlot(SimplePlot.Origin.UPPER_LEFT)
    #sp.addPixels(inline)
    
    
    return inline 
  else:
    #sf = SimpleFrame.asImagePanels(f)
    return f

def readImage(fileName,n1,n2,n3=1):
  if n3==1:
    x = zerofloat(n1,n2)
  else:
    x = zerofloat(n1,n2,n3)
  ais = ArrayInputStream(fileName)
  ais.readFloats(x)
  ais.close()
  return x

def plotSlice(st,sx,p,tmin=None,tmax=None,amin=None,amax=None,
    title=None,pngDir=None):
  sp = SimplePlot(SimplePlot.Origin.UPPER_LEFT)
  if title:
    if pngDir==None:
      sp.setTitle(title)
  sp.setHLabel("Offset (km)")
  sp.setVLabel("Time (s)")
  sp.setSize(400,750)
  sp.addColorBar()
  if tmin!=None and tmax!=None:
    sp.setVLimits(tmin,tmax)
  pv = sp.addPixels(st,sx,p)
  #pv.setColorModel(ColorMap.getRedWhiteBlue())
  if amax:
    if amin:
      pv.setClips(amin,amax)
    else:
      pv.setClips(-amax,amax)
  if pngDir:
    sp.paintToPng(1000,5,pngDir+title+".png")

def balance(sigma,f):
  f = add(max(f)*0.00001,f)
  ff = mul(f,f)
  RecursiveExponentialFilter(sigma).apply1(ff,ff)
  return div(f,sqrt(ff))

def createWarpedTime(st, a):
  nt = st.getCount()
  dt = st.getDelta()
  ft = st.getFirst()
  t = zerofloat(nt)
  t[0] = ft
  for i in range(1,nt):
    t[i] = t[i-1] + dt
  u = zerofloat(nt)

  #According to t = u(at)
  for i in range(1,nt):
    u[i] = a[i]*t[i]

  shifts = zerofloat(nt)
  #Final value minus starting value
  shifts = sub(u,t)
  
  #u is u(t)
  return t,u,shifts

def plotWavelets(st,hs,hmax=None,title=None,pngDir=None):
  sp = SimplePlot()
  ls = [PointsView.Line.SOLID,PointsView.Line.DASH,PointsView.Line.DOT]
  nh = len(hs)
  hsmax = 0
  for ih in range(nh):
    if hs[ih]:
      pv = sp.addPoints(st,hs[ih])
      pv.setLineStyle(ls[ih])
      pv.setLineWidth(2)
      hsmax = max(hsmax,abs(max(hs[ih])),abs(min(hs[ih])))
  if hmax==None:
    hmax = hsmax*1.05
  sp.setVLimits(-hmax,hmax)
  sp.setHLabel("Time (s)")
  sp.setVLabel("Amplitude")
  if title:
    if pngDir==None:
      sp.setTitle(title)
  if pngDir:
    sp.paintToPng(1000,5,pngDir+title+".png")

def plotTrace(st, p, tmin, tmax, amax, title): 
    sp = SimplePlot(SimplePlot.Origin.UPPER_LEFT)
    sp.setVLabel("Time (s)")
    sp.setSize(400,750)
    sp.setVLimits(tmin,tmax)
    sp.setHLimits(-amax,amax)
    sp.addTitle(title)
    pv = sp.addPoints(st,p)



#############################################################################
# Do everything on Swing thread.

class RunMain(Runnable):
  def run(self):
    main(sys.argv)
SwingUtilities.invokeLater(RunMain())


