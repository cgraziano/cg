/****************************************************************************
Copyright (c) 2014, Colorado School of Mines and others. All rights reserved.
This program and accompanying materials are made available under the terms of
the Common Public License - v1.0, which accompanies this distribution, and is
available at http://www.eclipse.org/legal/cpl-v10.html
****************************************************************************/
package seismology;

import edu.mines.jtk.dsp.*;
import edu.mines.jtk.interp.*;
import edu.mines.jtk.lapack.*;
import edu.mines.jtk.mosaic.*;//For debugging
import edu.mines.jtk.util.Check;
import static edu.mines.jtk.dsp.Conv.*;
import static edu.mines.jtk.util.ArrayMath.*;

/**
 * Simulates the wavefield generated by a point force in an unbounded homogeneous 
 * isotropic medium.
 * @author Chris Graziano, Colorado School of Mines
 * @version 2014.09.08
 */

 public class Wavefield {

  /**
   * Sets the properties of the medium the wavefield will travel through.
   * @param dens density of the rock (g/cm^3).
   * @param pwv p-wave velocity (m/s).
   * @param swv s-wave velocity (m/s).
  */ 
  public void setMediumProp(float dens, float pwv, float swv) {
    _dens = dens;
    _pwv = pwv;
    _swv = swv;
  }

  /**
   * Sets the frequency of a the source wavelet. Note: The source wavelet is a sine function.
   * @param freq frequency of the source wavelet (Hz).
   */
   public void setFreq(float freq) {
     _freq = freq;
   }

  /**
   * Calculates a component of displacement that was created by the wavefield 
   * at a certain time, a certain location, and with the force pointing in a certain
   * direction.
   * @param ucomp displacement component (1, 2, or 3).
   * @param fcomp direction the force is pointing in (1, 2, or 3).
   * @param t time the displacement component is calculated at (s).
   * @param st time the source is excited (s).
   * @param x x direction source-reciever distance (m). 
   * @param y y direction source-reciever distance (m). 
   * @param z z direction source-reciever distance (m). 
   * @param r radial distance between source and reciever (m).
   */
   public float calcDisplacement(int ucomp, int fcomp, float t, float dt, 
   float x, float y, float z, float r) {
     //time dependent part of near-field.
     float twopif = 2.0f*_pi*_freq;
     float twopifsq = twopif*twopif;
     float robeta = r/_swv;
     float roalpha = r/_pwv;
     float tdnf = calcTimeDepNearField(roalpha,robeta,t,dt);

     //near-field 
     float medpropnf = 1.0f/(4.0f*_pi*_dens);
     float rcubed = r*r*r;
     float orcubed = 1.0f/rcubed;
     float polarizenf = (3.0f*gamma(ucomp,x,y,z,r)*gamma(fcomp,x,y,z,r)-diracDelta(ucomp,fcomp));
     float nf = medpropnf*polarizenf*orcubed*tdnf;

     //far-field p-wave
     float medpropffp = 1.0f/(4.0f*_pi*_dens*_pwv*_pwv);
     float polarizeffp = gamma(ucomp,x,y,z,r)*gamma(fcomp,x,y,z,r);
     float or = 1.0f/r;
     float ffp = medpropffp*polarizeffp*or*sinx0(t-roalpha);

     //far-field s-wave
     float medpropffs = 1.0f/(4.0f*_pi*_dens*_swv*_swv);
     float polarizeffs = diracDelta(ucomp,fcomp)-gamma(ucomp,x,y,z,r)*gamma(fcomp,x,y,z,r);
     float ffs = medpropffs*polarizeffs*or*sinx0(t-robeta);
     return nf+ffp+ffs;
   }
   
   /**
    * Calculates the time dependent term in the near field term.
    * @param taomin lower limit of the time dependent near field term.
    * @param taomax upper limit of the time dependent near field term.
    * @param t time (s) to evaluate the time dependent term at.
    * @param dt sampling interval.
    */
   public float calcTimeDepNearField(float taomin, float taomax, float t, float dt) {
     float sum = 0.0f;
     float tao = 0.0f;
     int nt = (int)((taomax-taomin)/dt)+1;
     for (int i=0; i<=nt; ++i) {
       tao = i*dt+taomin;
       sum += tao*sinx0(t-tao)*dt;
     }
     return sum;
   }

   public float[] calcSeismogram(int ucomp, int fcomp, int nt, float ft, float dt,
                                  float x, float y, float z, float r) {
     float[] u = new float[nt];
     float t = 0.0f;
     for (int it=0; it<nt; ++it) {
       t = ft+it*dt;
       u[it] = calcDisplacement(ucomp,fcomp,t,dt,x,y,z,r);
     }
     return u;
   }

   public float[] calcSeismogram(int ucomp, int fcomp, int nt, float ft, float dt,
                                  float theta, float r) {
     float x = r*(float)cos(theta*PI/180.0);
     float y = 0.0f;
     float z = r*(float)sin(theta*PI/180.0);
     return calcSeismogram(ucomp,fcomp,nt,ft,dt,x,y,z,r);
   }

   public float[][] calcUThetas(int ucomp, int fcomp, int nthetas,
                                int nt, float ft, float dt, float r) {
     float dtheta = 90.0f/nthetas;
     float theta = 0.0f;
     float[][] uthetas = new float[nthetas][nt];
     for (int i=0; i<nthetas; ++i) {
       theta = i*dtheta;
       uthetas[i] = calcSeismogram(ucomp,fcomp,nt,ft,dt,theta,r);
     }
     return uthetas;
   }



   public float sinx0(float t) {
     float period = 1.0f/_freq;
     if (t>period)
       return 0.0f;
     else if (t<=0)
       return 0.0f;
     else 
       return (float) sin(2.0*PI*_freq*t);
   }

   public float cosx0(float t) {
     float period = 1.0f/_freq;
     if (t>period)
       return 0.0f;
     else if (t<0)
       return 0.0f;
     else 
       return (float) cos(2.0*PI*_freq*t);
   }


   /**
    * Calculates gamma, which is a directional cosine.
    * @param comp directional componenent (1, 2, or 3).
    * @param x x source-reciever distance (m). 
    * @param y y source-reciever distance (m). 
    * @param z z source-reciever distance (m). 
    * @param r radial distance between source and reciever (m).
    */
    public float gamma(int comp, float x, float y, float z, float r) {
      float xi = 0;
      if (comp==1) xi = x;
      else if (comp==2) xi = y;
      else xi = z;
      return xi/r;
    }

    /**
     * Calculates the value of a dirac delta function.
     * @param icomp i component.
     * @param jcomp j component.
     */
     public float diracDelta(int icomp, int jcomp) {
       if (icomp == jcomp) return 1.0f;
       else return 0.0f;
     }

     //******************private********************
     float _dens = 0.0f;
     float _pwv = 0.0f; 
     float _swv = 0.0f; 
     float _freq = 0.0f;
     float _dt = 0.0f;
     float _pi = (float) (PI);
 }
      


